---
layout: post
title: OOP란?
description: OOP란? 객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 
  '객체'들의 상호작용(메시지 주고받기, 데이터 처리 등)으로 프로그램 로직을 구성하는 프로그래밍 패러다임이다.
post-image: "https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/CPT-OOP-objects_and_classes_-_attmeth.svg/1280px-CPT-OOP-objects_and_classes_-_attmeth.svg.png"
author: 강준우
tags: 클래스 Static Heap Stack 오버라이딩 싱글톤패턴
---

# CH01 자바 OOP

[1. 클래스 vs 오브젝트 vs 인스턴스](#1-클래스-vs-오브젝트-vs-인스턴스)

[2. Static vs Heap vs Stack](#2-static-vs-heap-vs-stack)

[3. 상태와 행위](#3-상태와-행위)

[4. 상속 (추상화)](#4-상속-추상화)

[5. 오버라이딩](#5-오버라이딩)

[6. 싱글톤 패턴](#6-싱글톤-패턴)

<br>

## 1. 클래스 vs 오브젝트 vs 인스턴스

---

- 클래스는 설계도 (class 파일)
- 오브젝트는 존재 가능성(new 가능한 대상)
- 인스턴스는 존재하는 것(new 된 대상)

<br>

## 2. Static vs Heap vs Stack

----
### 2.1 static

- static은 main 메소드가 실행되기 전에 메모리에 로드된다. 즉 main 실행 전에 정적 할당된다.
- class가 없는 언어는 static 메모리가 없다.
- static은 class별로 존재한다.
- static은 자바 프로그램이 프로세스가 되었을 때 부터 자바 프로그램이 종료될 때까지 메모리에 존재한다.
- static 메모리를 관리하는 방법은 없다. 그냥 static 데이터는 최대한 적게 설계하는 것이다.
- static은 언제 사용 할까? 내 프로그램이 실행되고, 프로그램이 종료될 때까지 필요한 데이터가 필요하면 만든다.

> static은 main 메소드가 실행되기 전에 메모리에 단 한 번 로드되기 때문에 프로그램이 실행되는 동안 두번 메모리에 로드하는 방법은 없다.

### 2.2 HEAP

- heap은 class를 new할 때 메모리에 로드된다.
- 자바 프로그램이 실행되기 전에 메모리에 확보되는 것이 아니라, 실행 중에 확보된다. 즉 동적 할당된다.
- heap에 할당된 데이터는 'Garbage Collection'에 의해 관리된다.

> 태양이 static 메모리 공간에 정적 할당된다면! - 두 번 생성할 수 없다.
> 인간은 heap 메모리 공간에 동적 할당된다. - 계속 생성할 수 있다.

### 2.3 Stack

- stack은 메소드가 실행될 때 메모리에 로드된다.
- stack은 메소드가 종료될 때 메모리에서 사라진다.

<br>

> stack 메모리는 가장 짧은 생명주기를 가지는 메모리 공간이다.
> 메소드가 호출될 때 잠깐 할당되었다가,
> 메소드가 종료될 때 사라지기 때문에 관리가 필요 없다.

### 2.4 커피 빨리 마시기 대회

<br>

## 3. 상태와 행위

---

> 소나타 클래스

### 3.1 상태
- 기어 상태
- 속력
- 엔진 파워
- 색상

### 3.2 행위
- 기어 변경
- 엑셀 밟기

<br>

> new 하기 (자동차를 태어나게 하기)
> 우선 자동차가 이 세상에 존재해야 한다.

<br>

> constructor 사용하기 (자동차가 태어날 때)
> 자동차가 처음에 생성될 때 생성자를 통해 엔진파워와 색상을 초기화 한다.
 
> setter 사용하기 (자동차가 태어 난 뒤)
> 기어를 변경하면 기어 상태를 변경할 수 있다. 전진 or 후진
> 엑셀을 밟으면 속력의 상태를 변경할 수 있다.

> 엔진 파워와 색상에 대한 setter가 필요한가? setter란 무엇일 까?
> setter는 오브젝트의 상태 변화가 필요할 때 만드는 것이다.

### 3.3 객체(Object)의 상태는 행위에 의해서 변경된다

- 클래스의 멤버 변수를 상태(state)라고 한다.
- 클래스의 메소드를 행위(action)라고 한다.
- 객체의 상태를 초기화할 때는 생성자로 한다.
- 객체가 태어난 뒤 상태 변경이 일어나려면 행위가 필요하다. 행위에 의해서 상태를 변경한다.
- 상태에 직접 접근을 막기 ㅜ이해 상태에 privae 접근 제어자를 사용한다.
- 상태를 행위를 통해 변경하기 위해 public 메소드를 만든다.

<br>

## 4. 상속 (추상화)

---

> 상속(inheritance)이란 기존으 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미

> 상속에 목적은 추상화에 있다. 재사용에 있지 않다.
> 상속의 목적은은 추상화이고, 메소드 혹은 변수의 재사용은 추상화를 했기 때문에 얻어지는 부가적인 효과일 뿐이다.
> 즉, 재상용을 위해서 상속을 사용하지 않는다.

### 4.1 상속과 메모리

> 상속을 하게 될 때 메모리 구조가 어떻게 될까?

### 4.2 다형성(IS-A)

> 다형성(polymorphism)이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미

<br>

- 사과에게 너 과일이니?(가능)
- 사자에게 너 동물이니?(가능)
- 자동차에게 너 엔진이니?(불가능)

잘 만들어진 동물 클래스가 있다면, 사자 클래스를 만들 때, 동물 클래스를 상속 받아 만들면 편하게 만들 수 있다. 왜냐하면 상속을 하면 부모가 만들어 둔 메소드나, 변수를 재사용 할 수 있기 때문이다.

하지만, 잘 만들어진 엔진 클래스를 자동차가 상속해서 사용하면 안된다. 그 이유는 다형성이 성립하지 않기 때문이다.

다형성을 통해 DIP를 지킬 수 있다.
> DIP는 의존 관계를 맺을 때 **변화하기 쉬운 것 또는 자주 변화하는 것에 의존하기 보다는, 변화하기 어려운 것**, 거의 변화가 없는 것에 의존하라는 원칙(**Dependency Inverstion Principle**)

### 4.3 컴버지션 (HAS-A)

> 기존 클래스가 새로운 클래스의 구성요소가 되는 것

<br>
- 자동카 클래스를 만들 때, 잘 만들어진 엔진이 있으면 컴퍼지션한다.
- '컴퍼지션한다'는 것은 엔진 클래스를 자동차 클래스에 상태로 등록하는 것이다.

<br>

## 5. 오버라이딩

---

> 오버라이딩(overriding)이란 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하여 부모의 메소드를 무효화 시키는 것이다.

### 5.1 DIP

> 의존성 역전 원칙: 구체적인 것이 아닌 추상적인 것에 의존한다.

### 5.2 OCP

> 개방 폐쇄의 원칙: 기존 클래스의 코드를 변경하지 않고, 유지보수를 할 수 있다.

<br>

## 6. 싱글톤 패턴

> 싱글톤(Singleton) 패턴의 정의는 단순하다. **객체의 인스턴스가 오직 1개만 생성**되는 패턴을 의미

